# Title

## Summary

[summary]: #summary

Contract level messages are a facility that enable a smart contract to emit a message while executing which eventually gets sent on the event stream and is visible from outside the network.

## Motivation

[motivation]: #motivation

Under certain conditions, a contract may want to emit a message that an off-chain application may want to listen for and react to.
Currently there is no facility for a contract to emit this type of information in a way that the message is protected from spoofing and repudiation.
Because the execution effects are sent out on the event stream, in the past some contracts tried to simulate this type of functionality by writing messages to global state and then parsing the execution effects through a user-defined convention to extract the message. This is not secure in most scenarios because there it is no way to guarantee irrefutably where the message originated from (e.g. if a contract calls another contract, it may happen that the called contract emits a malicious message instead of the caller).

In order to provide a way for contracts to be able to emit messages that will ultimately show up in a controlled way on the event stream and can be observed after the execution is complete and committed, the execution engine needs to provide a facility that will allow the message to clearly and non-repudiably state who it originated from (what entity on chain created the message); there should also be some impact on the merkle proof that is generated when the message is emitted. 

## Guide-level explanation

[guide-level-explanation]: #guide-level-explanation

From a contract point of view, the execution engine will expose new special purpose FFIs that allow for emitting messages. Two new FFIs are introduced to enable this feature:
* manage message topics - `casper_manage_message_topic`
  * A contract may want to organize messages it emits into multiple categories. This is useful for the situation where a contract may want to send out messages where the progression is important (e.g. a token needs to be minted before it can be transferred) but also wants to send other unrelated messages on a different channel (e.g. changing settings or administrative tasks).
  * Also because the host needs to create indexed keys under which it would store the message checksums, the contract is required to register its intent to emit messages beforehand by registering a new message kind (a new topic) under which it will emit messages.
  * The first operation supported will be the `Add` operation which allows the contract to create a new topic on which it can emit messages on.
  * The number of topics a contract can register will be limited by a chainspec value.
* emitting messages - `casper_emit_message`
  * New messages are emitted under a pre-registered topic only.
  * The message emitted will be of a pre-defined message type which is an enum that will initially support sending out human readable strings but can be extended in the future to support other types.

When a new topic is registered through the `casper_manage_message_topic` FFI, the host creates a composite key derived from the callers entity address and the hash of the topic name.
This step is required in order for users to be able to verify messages later on by querying global state using a `Key` derived as mentioned above.
When querying global state for the topic control record, users can determine the number of messages that were emitted in the block that has the timestamp specified in the control record.

When the host receives these messages through the `casper_emit_message` FFI, the identity of the caller entity will be attached to the message automatically by the host.
The messages that are emitted will not be stored in global state; only a checksum of the message will be however stored. This allows users to verify the integrity of the message and also check that the message was indeed generated by the expected entity by doing a query to global state. The entries in global state are uniquely identified by the hash of the entity that emitted the message, the hash of the topic name and the index of the message.

Messages will be passed by the execution engine to the node that will eventually send them out on the event stream after the execution is complete and committed.
The messages sent out on the event stream contain the identity of the entity that emitted the message, the topic on which the message was emitted, the index of the message within the topic and the actual message payload.

**Note:** the messages themselves cannot be reconstructed by reading the entry from global state since that entry contains only the checksum of the messages sent.

## Reference-level explanation

[reference-level-explanation]: #reference-level-explanation

The implementation for supporting contract level messages requires changes in both the execution engine and the node.

### Changes to execution engine

#### Introduce new FFIs:
```rust
/// Manages a message topic with the specified name for the calling contract.
/// 
/// The topic name is a string of a maximum length that is specified in the chainspec.
/// The initially supported operation will be `Add` that registers a new message topic.
/// Will return an error if:
///     * the topic name length is exceeded
///     * the topic already exists (in case of the Add operation)
///     * the call was made from an `Account` context. We only allow stored contracts to register messages.
pub fn casper_manage_message_topic(
        topic_name_ptr: *const u8,
        topic_name_size: usize,
        operation_ptr: *const u8,
        operation_size: usize,
    ) -> i32;
```

```rust
/// Emits a new message on the specified topic.
/// 
/// The topic needs to have been already registered through a call to `casper_manage_message_topic` before emitting a message.
/// 
/// Will return an error if:
///     * the message is not of a serialized [`MessagePayload`] type.
///     * the length of the message is larger than the maximum length specified in the chainspec
pub fn casper_emit_message(
    topic_name_ptr: *const u8,
    topic_name_size: usize,
    message_ptr: *const u8,
    message_size: usize,
);
```

Apart from the new special purpose FFIs, a parameter is added to the `casper_add_package_version` FFI that allows managing message topics directly on contract install or upgrade.
Callers would need to pass the `message_topics_ptr` and `message_topics_size` which are a pointer to a map specifying the names of the topics and the operations to be performed on those topics.
```rust
/// Adds a new version to a package.
///
/// # Arguments
///
/// * `package_hash_ptr` - pointer to serialized package hash.
/// * `package_hash_size` - size of package hash in serialized form.
/// * `version_ptr` - output parameter where new version assigned by host is set
/// * `entry_points_ptr` - pointer to serialized [`casper_types::EntryPoints`]
/// * `entry_points_size` - size of serialized [`casper_types::EntryPoints`]
/// * `named_keys_ptr` - pointer to serialized [`casper_types::addressable_entity::NamedKeys`]
/// * `named_keys_size` - size of serialized [`casper_types::addressable_entity::NamedKeys`]
/// * `message_topics_ptr` - pointer to serialized [`BTreeMap<String, MessageTopicOperation>`]
///   containing message topic names and the operation to pe performed on each one.
/// * `message_topics_size` - size of serialized [`BTreeMap<String, MessageTopicOperation>`]
/// * `output_ptr` - pointer to a memory where host assigned contract hash is set to
/// * `output_size` - expected width of output (currently 32)
pub fn casper_add_package_version(
    package_hash_ptr: *const u8,
    package_hash_size: usize,
    version_ptr: *const u32,
    entry_points_ptr: *const u8,
    entry_points_size: usize,
    named_keys_ptr: *const u8,
    named_keys_size: usize,
    message_topics_ptr: *const u8,
    message_topics_size: usize,
    output_ptr: *mut u8,
    output_size: usize,
) -> i32;
```

The `MessagePayload` enum initially allows for sending messages represented either as human readable strings or `bytesrepr::Bytes` in the first iteration:
```rust
pub enum MessagePayload {
    /// Human readable string message.
    String(String),
    /// Message represented as raw bytes.
    Bytes(bytesrepr::Bytes),
}
```

#### A new singleton `Key::BlockMessageCount` variant is introduced to track message sequence:

```rust
pub enum Key {
    ...
    /// A `Key` under which the total number of emitted messages in the last block is stored.
    BlockMessageCount,
}
```

Each message that is emitted within a single block has an unique sequence number. This record is reset with every new created block.
The value written under this key is a tuple type `CLValue` representing the `(block_time, block_message_count)`.
The `block_message_count`represents the total number of messages emitted in the block with the corresponding `block_time`.
The block sequence id of the messages are global to the block and are not tied to entity address or topic.
The first message emitted in the block has block sequence id 0, the second message has block sequence id 1 and so on.

#### A new `Key` variant is introduced for indexing the message topic and message checksums:

```rust
pub enum Key {
    ...
    /// A `Key` under which a message topic or message checksum is stored.
    Message(MessageAddr),
}
```

`MessageAddr` is a composite key derived from the caller's entity address and a hash of the topic name:
```rust
pub struct MessageAddr {
    /// The entity addr.
    entity_addr: EntityAddr,
    /// A 32 byte BLAKE2b hash of the name of the message topic.
    topic_hash: TopicNameHash,
    /// The message index. If the message index is `None`, the `MessageAddr` points to the topic control record.
    message_index: Option<u32>,
}
```

There are 2 types of stored values that are written to global state under this key.

The control record for the message topic:
```rust
pub struct MessageTopicSummary {
    /// Number of messages in this topic.
    pub(crate) message_count: u32,
    /// Block timestamp in which these messages were emitted.
    pub(crate) blocktime: BlockTime,
}
```


Checksum of the message payload that was emitted:
```rust
//a 32 byte BLAKE2b hash of the serialized message sequence within the block and the `MessagePayload` that was emitted.
pub struct MessageChecksum(
    pub  [u8; 32],
);
```

When a new message is emitted on a specified topic the `message_count` in the `MessageTopicSummary` record is incremented.
With every message emitted during the execution of a block, a count is increased in the record stored under the `BlockMessageCount` key.
In summary, a message has an unique sequence id within the block it was emitted in and another unique sequence number within the topic it was emitted in. This allows tracking of the ordering of messages across multiple contract invocations within a single block.
Messages have ephemeral nature by design. In order to not increase the size of global state in an uncontrolled manner, the message count is reset to zero with every newly emitted message that belongs to a new block and the block time is updated as well. The old message checksum entries are pruned from global state.
Off-chain applications can still query the old message checksums if required by using the state root hash of the block where the messages were emitted.

**Note:** The checksum of the message is calculated by concatenating the serialized block sequence index with the serialized message payload: `crypto::blake2b((message_block_index, message_payload).to_bytes())`.

### Node changes

The Execution engine provides a result to the node in the form of an internal `ExecutionResult` data structure. In order to pass the message along to the node we need to extend the `ExecutionResults` to include the messages that were emitted during execution on both success and failure of the deploy.
The node will take the messages coming off the execution results in the `contract_runtime` component and will send them through the SSE hook as part of the `TransactionProcessed` SSE event.
The messages are extracted and only sent out the SSE event. The external facing `ExecutionResults` type from `casper-types` will not contain the messages. This is because execution results get stored in node storage. The messages have an ephemeral nature and should not be stored.

The `TransactionProcessed` SSE event will contain a `messages` field that will have an array of `Message` objects:

```rust
pub struct Message {
    /// The identity of the entity that produced the message.
    entity_addr: EntityAddr,
    /// The payload of the message.
    message: MessagePayload,
    /// The name of the topic on which the message was emitted.
    topic_name: String,
    /// The hash of the name of the topic.
    topic_name_hash: TopicNameHash,
    /// Message index in the topic.
    index: u32,
}
```

The modifications to global state that the host is making as part of emitting the message will appear in the results as a regular write transform for a new type of stored value.

### Discovering message topics

There is no SSE event emitted when a new message topic is created by a contract. However some applications need to determine which message topics are available in order to be able to properly listen to the messages emitted.
In order to make this information easy to access, the `AddressableEntity` record of the contracts will contain a new field called `message_topics` that will store a map between registered topic names and the topic name hash:
```rust
pub struct MessageTopics(
    BTreeMap<String, TopicNameHash>,
);
```

### Cost of emitting messages and chainspec limits

New chainspec limits are put in place to control the behavior of contract level messages. These limits are bundled into the `wasm` config settings in the chainspec as follows:
```toml
[wasm.messages_limits]
# Maximum size of the topic name.
max_topic_name_size = 256
# Maximum number of topics that can be added for each contract.
max_topics_per_contract = 128
# Maximum size in bytes of the serialized message payload.
max_message_size = 1_024
```

Since contract level messages are handled through FFIs, the gas cost related to using the new interface is captured in the `wasm.host_function_costs` chainspec settings:
```toml
[wasm.host_function_costs]
manage_message_topic = { cost = 200, arguments = [0, 0, 0, 0] }
emit_message = { cost = 200, arguments = [0, 0, 0, 0] }
cost_increase_per_message = 50
```

The `cost_increase_per_message` parameter allows the configuration of increasing gas cost when emitting multiple messages within a single execution. In the example above, within a single execution, the first call to `casper_emit_message` will have gas cost 200, the second call will have cost 250 and each subsequent call will increase gas cost by `cost_increase_per_message`.
The next execution will start again with the same gas cost.

Storage cost will be charged based on the `wasm.storage_costs.gas_per_byte` chainspec parameter.

For each emitted message 3 records are written in global state: the topic control record, the message checksum and the block message count record is changed. Writing these records incurs a fixed cost based on `gas_per_byte`.

When a new topic is added 2 records are written in global state: the topic control record and the addressable entity record that is extended with the new topic name and topic name hash. Because the topic name is variable, the cost depends on the length of the topic name.

### Upgrading contracts

When a new contract version is added the message topics registered from the previous version are carried over to the new contract automatically.
The `message_topics` of the previous `AddressableEntity` will be copied to the new one and a new control record will be written for each topic for the new entity.

### Corelation of messages across multiple topics and contracts

Messages are always ordered within a topic. In some cases, users would like to know the sequencing of emitted messages across multiple topics. This can be achieved in a few ways:

#### Using an ordering topic inside the contract (user-level)
If a contract wants to allow other parities to check the sequence of messages that were emitted across two or more message topics, it can create a new topic that is used to keep the ordering of messages across the other topics. Every time that a message is emitted on a specific topic, the contract would also emit a message on the ordering topic with the ID or Key of the original message.
The disadvantage of this method is that it's a technique that is only available if the contract opts in to do this work; some contracts may not implement this so consumers of the contract would not be able to easily understand the sequencing of messages across multiple topics. Also this works only for topics registered under a single contract.
The advantage of this method is that it can provide lightweight correlation of message topics that leverages the existing messaging infrastructure and provides low noise (only messages from topics that need to be correlated will end up on the ordering topic).

#### Inspecting the execution journal (off-chain metadata)
When a transaction/deploy is processed, a log of the transforms that were applied to global state is emitted in the form of the execution results. Since every emitted message has a direct side-effect in global state by writing the message checksum, contract consumers can determine the sequence of the emitted messages by tracking the writes under the `Key::Message` in the log. By doing this, consumers can even track sequencing across messages emitted by multiple different contracts since the keys under which checksums are written are derived from the addressable entity hash.
However this log of transforms is not committed in global state so consumers must ensure that the node providing the log can be trusted.

#### Correlating message block sequence ids

Each message gets assigned an unique sequence id within the block it was emitted in. For example, if in block with block time X contract A is executed and emits a message and then contract B is executed next and emits a different message, the first message will have block sequence id 0, the second message will have block sequence id 1. The value written under `Key::BlockMessageCount` will be `(X, 2)`.
With this information available, we can strictly determine that the message generated by contract A was emitted before the one generated by contract B. We can be sure that this order is true because the checksum stored in global state is calculated by considering these block sequence ids. We can also determine the exact number of messages that were emitted during the execution of this block.

## Rationale and alternatives

[rationale-and-alternatives]: #rationale-and-alternatives

As an alternative to creating a separate `Key` variant for storing the message summaries a regular `URef` could be used. Emitting messages could then piggyback on the `write` FFI by introducing a new type of stored value type. This `URef` would be granted to the entity that produced it and add it to its named keys.
The problem with this approach is that if a lot of messages are produced, the number of named keys can become too high. By default the URef would have Read-Add-Write permissions which would also be problematic because with write permission the value under that `URef` can be modified at any time. Also since URefs can be proliferated this would mean that potentially other entities could be able to change the messages checksums which again would weaken the validity check for the emitted messages.

Another way to provide discoverability of the message summaries would be for the host to create a composite key based upon the addressable entity's hash (first 32 bytes) and the message checksum (last 32 bytes). When a request for verification comes in, for the entity that emitted the message a key prefix can query for all the messages that the entity emitted and then check the tail of the key to see if the checksum match. If none of the suffixes match then it means that the message wasn't emitted. The issue with this approach is that this could possibly create an attack vector by someone asking for verification and forcing a node to go through a large number of key records that don't match with the suffix.

For passing the messages to the node an alternative to extending the `ExecutionResult` structure would be to add a new variant to the `TransformKind` enum called `Message` that will need to have the source entity address and the message string. The node would then extract the messages from the transforms. This approach has some semantic issues because the transforms represent a commit log that will be applied to the database and the messages will not actually be committed to the database. 

## Prior art

[prior-art]: #prior-art

Ethereum has a similar mechanism that allows smart contracts to emit events and write logs that can be processed by a subscribing application.
See: [Logging data from smart contracts with events](https://ethereum.org/uz/developers/tutorials/logging-events-smart-contracts/)

## Unresolved questions

[unresolved-questions]: #unresolved-questions

## Future possibilities

[future-possibilities]: #future-possibilities

Currently this proposal focuses on allowing contracts to emit messages. In the future we might want to emit messages when certain system level events happen (e.g. when a contract is installed or upgraded). This will be considered for future iterations.